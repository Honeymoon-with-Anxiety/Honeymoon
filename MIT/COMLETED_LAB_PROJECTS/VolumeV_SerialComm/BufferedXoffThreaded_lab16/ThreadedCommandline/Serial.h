// Serial.h

#ifndef __SERIAL_H__
#define __SERIAL_H__


#define FC_DTRDSR       0x01
#define FC_RTSCTS       0x02
#define FC_XONXOFF      0x04
#define ASCII_BEL       0x07
#define ASCII_BS        0x08
#define ASCII_LF        0x0A
#define ASCII_CR        0x0D
#define ASCII_XON       0x11
#define ASCII_XOFF      0x13
#define START_TRANS		0x15
#define END_TRANS		0x17

class CInputThread;
class COutputThread;
class CCommandLineTestDlg;

class CSerial
{

public:
	CSerial();
	~CSerial();

	BOOL Open( int nPort = 2, int nBaud = 9600 );
	BOOL Close( void );

	int ReadData( void *, int );
	int SendData( const char *, int );
	int ReadDataWaiting( void );

	BOOL IsOpened( void ){ return( m_bOpened ); }

	void SetOwner(CCommandLineTestDlg* m_p){m_pOwner = m_p;}

//protected:
	CCommandLineTestDlg* m_pOwner;

	BOOL WriteCommByte( unsigned char );

	HANDLE m_hIDComDev;	//handle (to the communication device)
						//used by the overlapped I/O part of
						//of the Win32 file system (you will wait for the 
						//I/O to complete) will be used for read and write
	
	
	COutputThread* m_pOutputThread;

	//output event handles
	HANDLE m_hKillOutputThreadEvent;	//terminate the output thread
	HANDLE m_hWriteRequestEvent;		//generated by user for each line to send
	HANDLE m_hWriteByteRequestEvent;	//generated by input thread when the
										//reply to the most recently sent byte
										//was not XOFF

	//input handles
	CInputThread* m_pInputThread;
	HANDLE m_hKillInputThreadEvent;
	HANDLE m_hReadRequestEvent;
	HANDLE m_hTransmissionCompleteEvent;		//EOT encountered by the input thread
	BOOL m_bInputThreadReading;

protected:
	OVERLAPPED m_OverlappedWrite,m_OverlappedRead;
	BOOL m_bOpened;

};

#endif
