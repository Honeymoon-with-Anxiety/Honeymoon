// threads.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
// This sample application is derived from the Mutex application
// distributed with Jeffrey Richter's "Advanced Windows" programming book
// (Microsoft Press).  See the book for more information about Win32
// programming topics, including thread synchronization.

#include "stdafx.h"
#include "CommandLineTest.h"
#include "CommandLineTestDlg.h"
#include "Threads.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CExampleThread, CWinThread)

CExampleThread::CExampleThread()
{
	m_bDone = FALSE;
	m_pOwner = NULL;
	m_bAutoDelete = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CCounterThread

IMPLEMENT_DYNCREATE(COutputThread, CExampleThread)

COutputThread::COutputThread()
{
}

COutputThread::~COutputThread()
{
	delete [] buffer_out;
}

BOOL COutputThread::InitInstance()
{
	// TODO:  perform and per-thread initialization here
	buffer_out=NULL;
	buffer_out_length=0;
	cur_byte=0;

	return TRUE;
}

void COutputThread::SetBufferOut(CString& S)
{//copies the CString to be sent into a char buffer
	if(buffer_out!=NULL) delete [] buffer_out;
	
		
		int length = S.GetLength();
		buffer_out= new unsigned char [length+1];
		ASSERT (buffer_out);
		for(cur_byte=0;cur_byte<length;cur_byte++)
			buffer_out[cur_byte]=S[cur_byte];

			buffer_out[cur_byte]=END_TRANS;
			buffer_out_length = cur_byte+1;
			cur_byte=0;
	
}

int COutputThread::Run()
{
	
	if (m_pOwner == NULL)
		return -1;
	HANDLE event_handles[4] = { m_pOwner->m_hKillOutputThreadEvent,
								m_pOwner->m_hWriteRequestEvent,
								m_pOwner->m_hWriteByteRequestEvent,
								m_pOwner->m_hTransmissionCompleteEvent};

	while (!m_bDone)
	{
		switch(WaitForMultipleObjects(4,event_handles,FALSE,FALSE))
		{
		case 0://m_KillOutputThreadEvent
			m_bDone=TRUE;
			break;
		case 1://m_hWriteRequestEvent generated by user when new line is ready
				//assuming that you are done sending the previous buffer
			ResetEvent(m_pOwner->m_hWriteRequestEvent);//manual SetEvent
			m_pOwner->WriteCommByte(buffer_out[cur_byte]); 
			cur_byte++;

			break;
		case 2://m_hWriteByteRequestEvent generated by the input thread 
				//when the most recently received byte was not XOFF
			ResetEvent(m_pOwner->m_hWriteByteRequestEvent);
			if(cur_byte<buffer_out_length)
			{
				m_pOwner->WriteCommByte(buffer_out[cur_byte]);
				cur_byte++;
			}
			break;
		case 3:
			ResetEvent(m_pOwner->m_hTransmissionCompleteEvent);
			m_pOwner->m_pOwner->
				m_CommandLine.AddRecv(
					m_pOwner->m_pInputThread->ReadLine);
						m_pOwner->m_pInputThread->ReadLine="";

			break;
		default: 
			ASSERT(false);
		}//end switch
		
	}

	return 0;
}

BEGIN_MESSAGE_MAP(COutputThread, CWinThread)
	//{{AFX_MSG_MAP(COutputThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutputThread message handlers
/////////////////////////////////////////////////////////////////////////////
// CInputThread

IMPLEMENT_DYNCREATE(CInputThread, CExampleThread)

CInputThread::CInputThread()
{
}

CInputThread::~CInputThread()
{
}

BOOL CInputThread::InitInstance()
{
	// TODO:  perform and per-thread initialization here
	ReadLine = "";
	m_bX_OFF = false;
	return TRUE;
}

int CInputThread::Run()
{

	ASSERT(m_pOwner != NULL);
	if (m_pOwner == NULL)
		return -1;

	DWORD dwErrorFlags;
	COMSTAT ComStat;
	ClearCommError( m_pOwner->m_hIDComDev, &dwErrorFlags, &ComStat );

	OVERLAPPED AsyncReadInfo = {0};
	OVERLAPPED AsyncStatusInfo = {0};

	AsyncReadInfo.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
	AsyncStatusInfo.hEvent= CreateEvent(NULL,TRUE,FALSE,NULL);

	ASSERT(AsyncReadInfo.hEvent); 
	ASSERT(AsyncStatusInfo.hEvent);

	DWORD dwCommEvent;
	BOOL waiting_on_status = false;
	m_pOwner->m_bInputThreadReading=false;

	HANDLE handles[4]={	m_pOwner->m_hKillInputThreadEvent,
						AsyncReadInfo.hEvent,
						AsyncStatusInfo.hEvent,
						m_pOwner->m_hReadRequestEvent};


	SetCommMask(m_pOwner->m_hIDComDev, EV_ERR);


	while (!m_bDone)
	{
		int bytes_to_read = 256;
		char read_buffer[256];
		DWORD dwBytesRead;


		if(!m_pOwner->m_bInputThreadReading)
		{	
			if(!ReadFile(m_pOwner->m_hIDComDev,read_buffer,bytes_to_read,
							&dwBytesRead, &AsyncReadInfo))
			{
				m_pOwner->m_bInputThreadReading=true;
			}//if not ReadFile
			else
			{	//ReadFile returned immediatelly so check if you 
				//got X_OFF or not, if not set the write request event
				//ReadLine="";
				for(int i=0;i<dwBytesRead;i++)
				{	
					if(read_buffer[i]==ASCII_XOFF) m_bX_OFF=true;
					else if(read_buffer[i]==ASCII_XON) m_bX_OFF = false;
					else if(read_buffer[i]==END_TRANS) 
						SetEvent(m_pOwner->m_hTransmissionCompleteEvent);
					else 
					{
						ReadLine+=read_buffer[i];
						SetEvent(m_pOwner->m_hWriteByteRequestEvent);
					}
				}			
				
				
				if(!m_bX_OFF) SetEvent(m_pOwner->m_hWriteByteRequestEvent);				
			}
		}//if not input thread reading





		if(!waiting_on_status)
		{
			if(!WaitCommEvent(	m_pOwner->m_hIDComDev,
								&dwCommEvent,
								&AsyncStatusInfo))
			{
				waiting_on_status = true;
			}//waintcommevent
			else // WaitCommEvent returned immediately
			{
				ClearCommError( m_pOwner->m_hIDComDev, 
					&dwErrorFlags, &ComStat );
			}
		}//if not waiting on status




		if(waiting_on_status&&
			(m_pOwner->m_bInputThreadReading||bytes_to_read==0))
		{
			DWORD result = WaitForMultipleObjects(4,
									handles,
									FALSE,
									INFINITE
									);
			switch(result)
			{
			case 0:
				m_bDone = true;
				break;

			case 1:
				if(GetOverlappedResult(m_pOwner->m_hIDComDev,
										&AsyncReadInfo,
										&dwBytesRead,
										FALSE))
				{
					//ReadLine="";
					for(int i=0;i<dwBytesRead;i++)
					{	
						if(read_buffer[i]==ASCII_XOFF) m_bX_OFF=true;
						else if(read_buffer[i]==ASCII_XON) m_bX_OFF = false;
						else if(read_buffer[i]==END_TRANS)
							SetEvent(m_pOwner->m_hTransmissionCompleteEvent);
						else 
						{
							ReadLine+=read_buffer[i];
							SetEvent(m_pOwner->m_hWriteByteRequestEvent);
						}
					}
		


					if(!m_bX_OFF) SetEvent(m_pOwner->m_hWriteByteRequestEvent);
					
					m_pOwner->m_bInputThreadReading=false;
					break;
				}//if getOverlappedREs...

			case 2:
				DWORD dwOverlappedResult;
				if(GetOverlappedResult(	m_pOwner->m_hIDComDev,
										&AsyncStatusInfo,
										&dwOverlappedResult,
										FALSE))
				{
						ClearCommError( m_pOwner->m_hIDComDev, 
					&dwErrorFlags, &ComStat );
				}

				waiting_on_status = false;
				break;
			case 3:
				TRACE("INPUT THREAD WOKEN UP");
				
				break;

			default:
				ASSERT(FALSE);
			}//end switch

		}

	}//while not done

	CloseHandle(AsyncReadInfo.hEvent);
	CloseHandle(AsyncStatusInfo.hEvent);

	return 0;
}//end run() input thread 

BEGIN_MESSAGE_MAP(CInputThread, CWinThread)
	//{{AFX_MSG_MAP(CInputThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInputThread message handlers
